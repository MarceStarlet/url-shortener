package services

import javax.inject.{ Inject, Singleton }
import models.ShortURL
import play.api.Logger
import reactivemongo.api.commands.WriteResult
import reactivemongo.bson.{ BSONObjectID }
import repositories.ShortURLMongo

import scala.concurrent.{ ExecutionContext, Future }

/**
 * The shortener url service
 */
trait ShortURLGenerator {

  /**
   * Creates a new short URL if necessary
   * @param original
   * @return
   */
  def createShortURL(original: String): Future[String]

  /**
   * Resolves the original URL of a shorted id
   * @param shorted
   * @return
   */
  def resolveOriginalURL(shorted: String): Future[Option[String]]

}

@Singleton
class ShortURLGeneratorServ @Inject() (implicit ec: ExecutionContext, shortURLMongo: ShortURLMongo)
  extends ShortURLGenerator {

  private val logger = Logger(getClass)

  override def createShortURL(original: String): Future[String] = {
    logger.info("Creating new short URL")

    val verifiedURL = verifyURL(original)

    shortURLMongo.findByOriginalURL(verifiedURL).flatMap { shorted =>
      if (shorted.isEmpty) {
        val mongoId = getMongoId()

        val shourtURLId = generateShortId(mongoId)

        val shortURL = ShortURL(Some(mongoId), verifiedURL, shourtURLId, System.currentTimeMillis(),
          System.currentTimeMillis())

        val result: Future[WriteResult] = shortURLMongo.save(shortURL)

        Future(shourtURLId)
      } else {
        Future(shorted)
      }
    }
  }

  override def resolveOriginalURL(shorted: String): Future[Option[String]] = {
    logger.info("Resolving the original URL of a shorted id")

    shortURLMongo.findByShortId(shorted).flatMap { original =>
      if (original.isEmpty) {
        Future(None)
      } else {
        Future(Some(original))
      }
    }
  }

  private def getMongoId(): BSONObjectID = {
    BSONObjectID.generate()
  }

  /**
   * Generates the short id for an URL by taking the 'increment' segment
   * of the ObjectId generated by the <code>ReactiveMongoApi</code>.
   *
   * This method assures aprox 16 millions (16777216) + base conversions,
   * of different new values before collisions. This is for a single machine
   *
   * @param mongoId
   * @return
   */
  private def generateShortId(mongoId: BSONObjectID): String = {
    segmentId(mongoId)("increment")
  }

  /**
   * Generates an improved short id for an URL by taking the 'machine' and
   * 'increment' segments of the ObjectId generated by the <code>ReactiveMongoApi</code>.
   *
   * This method assures the 'increment' segment new values +  the 'machine' segment which
   * will be the difference in a distributed system.
   * @param mongoId
   * @return
   */
  private def generateShortIdForCollisions(mongoId: BSONObjectID): String = {
    val segments = segmentId(mongoId)
    s"${segments("machine")}${segments("increment")}"
  }

  /**
   * BSON ObjectId value.
   * Segments the ObjectId.
   * The segments are used to generate the short id for an URL.
   *
   * +------------------------+------------------------+------------------------+------------------------+
   * + timestamp (in seconds) +   machine identifier   +    thread identifier   +        increment       +
   * +        (4 bytes)       +        (3 bytes)       +        (2 bytes)       +        (3 bytes)       +
   * +------------------------+------------------------+------------------------+------------------------+
   */
  private def segmentId(mongoId: BSONObjectID): Map[String, String] = {
    val id = mongoId.stringify

    Map(
      "timestamp" -> id.take(8),
      "machine" -> id.slice(8, 8 + 6),
      "thread" -> id.slice(8 + 6, 8 + 6 + 4),
      "increment" -> id.takeRight(6))

  }

  private def verifyURL(url: String): String = {
    val protocols = List("http://", "https://")
    protocols.exists(protocol => url.toLowerCase.startsWith(protocol)) match {
      case false => s"${protocols(0)}${url}"
      case true => url
    }
  }

}
